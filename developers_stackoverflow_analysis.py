# -*- coding: utf-8 -*-
"""developers_stackoverflow_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C5YDNcfFBYb_4FWLo-eN_EpYMcjrrhlf

Analyzing Stackover
"""

import io
import zipfile
import requests
import os
import glob
import re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""## **Data understanding**

---


"""

schema = pd.read_csv('survey_results_schema.csv')
print(schema.head())

responses = pd.read_csv('survey_results_public.csv')
print(responses.head())

column_names = responses.columns
print(column_names)

# Check data types and basic structure
print("Data Types:")
print(responses.dtypes)
print("\nDescriptive Statistics:")
print(responses.describe())

"""# DATA CLEANING"""

responses[responses.columns].isnull().sum()

important_columns = ['CompanyType', 'YearsProgram', 'JobSatisfaction', 'HomeRemote', 'Salary']

responses[important_columns].isnull().sum()

#% of companies with missing values
responses.CompanyType.isnull().sum() / responses.shape[0] * 100

#% of missing salaries
responses.Salary.isnull().sum() / responses.shape[0] * 100

"""Analysis:

- Almost 25% of the company type values are missing. We will drop the missing values as it can't be appropriately filled with any other measure.

- 75% of the salaries are missing. Filling (with avg, or mean or mode) would cause disruption in the proportion of the data. Hence, we will drop.

For the remaining null values of rows:
- YearsProgram	: Fill in with mode
- JobSatisfaction	: Fill in with mean
- HomeRemote : Fill in with mode
"""

responses.JobSatisfaction.fillna(responses.JobSatisfaction.mean(), inplace=True)
responses.YearsProgram.fillna(responses.YearsProgram.mode()[0], inplace=True)
responses.HomeRemote.fillna(responses.HomeRemote.mode()[0], inplace=True)



"""# Dropping the rows with missing Company Type and Salary:

---


"""

responses = responses.dropna(subset=['CompanyType', 'Salary']).reset_index(drop=True)

responses[important_columns].isnull().sum()

sns.set_palette("BuGn_d")
teal_palette = sns.color_palette(["#008080", "#20B2AA", "#40E0D0", "#66CDAA", "#AFEEEE"])
sns.set_palette(teal_palette)
sns.set_style("whitegrid")

country_counts = responses['Country'].value_counts().head(10)
sns.barplot(x=country_counts.values, y=country_counts.index)
plt.title("Top 10 Countries by Respondent Count")
plt.xlabel("Number of Respondents")
plt.ylabel("Country")
plt.show()

gender_counts = responses['Gender'].apply(lambda x: x if x in ['Male', 'Female', 'Gender non-conforming'] else 'Other').value_counts()
company_employment = responses.groupby(['CompanySize', 'EmploymentStatus']).size().unstack().fillna(0)

# Filter to keep only full-time and part-time employment statuses
filtered_employment = company_employment[['Employed full-time', 'Employed part-time']]
# Define teal colors for the pie chart, limiting to three categories plus 'Other' if applicable
teal_colors = ["#008080", "#20B2AA", "#40E0D0", "#AFEEEE"]

plt.figure(figsize=(8, 8))
plt.pie(gender_counts, labels=gender_counts.index, colors=teal_colors[:len(gender_counts)],
        autopct='%1.1f%%', startangle=140, wedgeprops={'edgecolor': 'gray'})

plt.title("Gender Distribution")
plt.show()

major_counts = responses['MajorUndergrad'].value_counts().head(10)
sns.barplot(x=major_counts.values, y=major_counts.index)
plt.title("Top 10 Undergraduate Majors")
plt.xlabel("Number of Respondents")
plt.ylabel("Undergraduate Major")
plt.show()

# Group by CompanySize and EmploymentStatus, then unstack
company_employment = responses.groupby(['CompanySize', 'EmploymentStatus']).size().unstack().fillna(0)

# Filter to keep only full-time and part-time employment statuses
filtered_employment = company_employment[['Employed full-time', 'Employed part-time']]

# Plot the filtered data
filtered_employment.plot(kind='bar', stacked=True, figsize=(12, 6), color=teal_palette)
plt.title("Company Size vs Employment Status (Full-time vs Part-time)")
plt.xlabel("Company Size")
plt.ylabel("Number of Respondents")
plt.legend(title="Employment Status")
plt.show()

remote_work_counts = responses['HomeRemote'].value_counts()
sns.barplot(x=remote_work_counts.values, y=remote_work_counts.index)
plt.title("Remote Work Preferences")
plt.xlabel("Number of Respondents")
plt.ylabel("Remote Work Status")
plt.show()

sns.histplot(data=responses, x='Salary', bins=30, kde=True, color="#008080")
plt.title("Salary Distribution")
plt.xlabel("Salary")
plt.ylabel("Frequency")
plt.show()

hobby_counts = responses['ProgramHobby'].value_counts()
sns.barplot(x=hobby_counts.values, y=hobby_counts.index)
plt.title("Programming as a Hobby")
plt.xlabel("Number of Respondents")
plt.ylabel("Program Hobby Status")
plt.show()

money_counts = responses['StackOverflowMakeMoney'].value_counts()
sns.barplot(x=money_counts.values, y=money_counts.index)
plt.title("Using Stack Overflow for Monetization")
plt.xlabel("Number of Respondents")
plt.ylabel("Monetization Status")
plt.show()

parent_education_counts = responses['HighestEducationParents'].value_counts()
sns.barplot(x=parent_education_counts.values, y=parent_education_counts.index)
plt.title("Highest Education Level of Respondents' Parents")
plt.xlabel("Number of Respondents")
plt.ylabel("Education Level")
plt.show()

from matplotlib.backends.backend_pdf import PdfPages

# Function to save all plots in a single PDF
def save_all_plots_to_pdf():
    with PdfPages('/content/plots.pdf') as pdf:
        for i, figure_num in enumerate(plt.get_fignums()):
            fig = plt.figure(figure_num)
            pdf.savefig(fig)  # Save each figure in the PDF
    files.download('/content/plots.pdf')

save_all_plots_to_pdf()



"""# Visualizations:"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Load the dataset
responses = pd.read_csv('survey_results_public.csv')

# Clean the Salary data
responses['Salary'] = pd.to_numeric(responses['Salary'], errors='coerce')
responses.dropna(subset=['Salary'], inplace=True)  # Drop rows with NaN Salary

# Check for unique values in the Professional column to ensure categories are manageable
print("Unique Professional Categories:")
print(responses['Professional'].unique())

# Set the aesthetic style of the plots
sns.set(style='whitegrid')

# Create a boxplot to visualize the salary distribution across different professional categories
plt.figure(figsize=(14, 8))
sns.boxplot(x='Salary', y='Professional', data=responses, palette='Set3')
plt.title('Salary Distribution by Professional Category', fontsize=16)
plt.xlabel('Salary', fontsize=14)
plt.ylabel('Professional Category', fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.tight_layout()  # Adjust layout to avoid clipping
plt.show()  # Display the plot

